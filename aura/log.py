# Copyright 2024-2025 SURF.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from datetime import datetime
from logging import Filter, Handler, LogRecord, config, getLogger
from uuid import UUID

import structlog

from aura.db import Session
from aura.model import Log, Reservation
from aura.settings import settings


class DatabaseLogHandler(Handler):
    def emit(self, record: LogRecord) -> None:
        """Filter structlog generated messages and store reservation related ones in the database."""
        with Session.begin() as session:
            # when msg attribute exists and is a dict, then the message is generated by structlog
            if hasattr(record, "msg") and isinstance(record.msg, dict):
                # check for anything that can map this message to a know reservation
                if "reservationId" in record.msg:
                    reservationId = record.msg["reservationId"]
                elif "connectionId" in record.msg and record.msg["connectionId"] != "None":
                    reservationId = (
                        session.query(Reservation.id)  # type: ignore
                        .filter(Reservation.connectionId == UUID(record.msg["connectionId"]))
                        .scalar()
                    )
                elif "globalReservationId" in record.msg:
                    reservationId = (
                        session.query(Reservation.id)  # type: ignore
                        .filter(Reservation.globalReservationId == UUID(record.msg["globalReservationId"]))
                        .scalar()
                    )
                elif "correlationId" in record.msg:
                    reservationId = (
                        session.query(Reservation.id)  # type: ignore
                        .filter(Reservation.correlationId == UUID(record.msg["correlationId"]))
                        .scalar()
                    )
                else:
                    reservationId = -1
                # store the reservation related message in the database
                if reservationId >= 0:
                    session.add(
                        Log(
                            reservation_id=reservationId,
                            name=record.name,
                            module=record.module,
                            line=record.lineno,
                            function=record.funcName,
                            filename=record.filename,
                            timestamp=datetime.fromtimestamp(record.created),
                            message=record.msg["event"],
                        )
                    )


class UvicornAccessLogFilter(Filter):
    """Uvicorn's access log filter."""

    def filter(self, record: LogRecord) -> bool:
        """Filter out messages for certain endpoints.

        Currently only filter out /healthcheck access messages.
        """
        if record.args and len(record.args) >= 3:
            if record.args[2] in ["/healthcheck"]:
                return False
        return True


def init() -> None:
    timestamper = structlog.processors.TimeStamper(fmt="iso")
    pre_chain = [
        # Add the log level and a timestamp to the event_dict if the log entry
        # is not from structlog.
        structlog.stdlib.add_log_level,
        # Add extra attributes of LogRecord objects to the event dictionary
        # so that values passed in the extra parameter of log methods pass
        # through to log output.
        # structlog.stdlib.ExtraAdder(), # disabled to remove color_message= from uvicorn logs
        timestamper,
    ]

    # def extract_from_record(_, __, event_dict):
    #     """Extract thread and process names and add them to the event dict."""
    #     record = event_dict["_record"]
    #     event_dict["thread_name"] = record.threadName
    #     event_dict["process_name"] = record.processName
    #     return event_dict

    config.dictConfig(
        {
            "version": 1,
            "disable_existing_loggers": True,
            "formatters": {
                "plain": {
                    "()": structlog.stdlib.ProcessorFormatter,
                    "processors": [
                        structlog.stdlib.ProcessorFormatter.remove_processors_meta,
                        structlog.dev.ConsoleRenderer(colors=False),
                    ],
                    "foreign_pre_chain": pre_chain,
                },
                "colored": {
                    "()": structlog.stdlib.ProcessorFormatter,
                    "processors": [
                        # extract_from_record,
                        structlog.stdlib.ProcessorFormatter.remove_processors_meta,
                        structlog.dev.ConsoleRenderer(colors=True),
                    ],
                    "foreign_pre_chain": pre_chain,
                },
            },
            "handlers": {
                "default": {
                    "level": "DEBUG",
                    "class": "logging.StreamHandler",
                    "formatter": "colored",
                },
                "file": {
                    "level": "DEBUG",
                    "class": "logging.handlers.WatchedFileHandler",
                    "filename": "aura.log",
                    "formatter": "plain",
                },
                "database": {
                    "level": "DEBUG",
                    "class": "aura.log.DatabaseLogHandler",
                    "formatter": "plain",
                },
            },
            "loggers": {
                "": {
                    "handlers": ["default", "file", "database"],
                    "level": settings.LOG_LEVEL,
                    "propagate": True,
                },
                # Set `level` to `INFO` or `DEBUG` here for detailed SQLAlchemy logging.
                "sqlalchemy.engine": {
                    "handlers": ["default"],
                    "level": "WARNING",
                    "propagate": False,
                },
                # APScheduler loglevel `INFO` is still to noisy, change to WARNING instead.
                "apscheduler.scheduler": {
                    "handlers": ["default"],
                    "level": settings.LOG_LEVEL if settings.LOG_LEVEL != "INFO" else "WARNING",
                    "propagate": False,
                },
                "apscheduler.jobstores": {
                    "handlers": ["default"],
                    "level": settings.LOG_LEVEL if settings.LOG_LEVEL != "INFO" else "WARNING",
                    "propagate": False,
                },
                "apscheduler.executors": {
                    "handlers": ["default"],
                    "level": settings.LOG_LEVEL if settings.LOG_LEVEL != "INFO" else "WARNING",
                    "propagate": False,
                },
                "apscheduler": {
                    "handlers": ["default"],
                    "level": settings.LOG_LEVEL if settings.LOG_LEVEL != "INFO" else "WARNING",
                    "propagate": False,
                },
                "uvicorn.access": {
                    "handlers": ["default", "file", "database"],
                    "level": settings.LOG_LEVEL,
                    "propagate": False,
                },
                "uvicorn.error": {
                    "handlers": ["default", "file", "database"],
                    "level": settings.LOG_LEVEL,
                    "propagate": False,
                },
            },
        }
    )

    uvicorn_access_logger = getLogger("uvicorn.access")
    uvicorn_access_logger.addFilter(UvicornAccessLogFilter())

    # logging.getLogger("uvicorn.error").disabled = True
    # logging.getLogger("uvicorn.access").disabled = True

    structlog.configure(
        processors=[
            structlog.stdlib.add_log_level,
            structlog.stdlib.add_logger_name,
            structlog.stdlib.PositionalArgumentsFormatter(),
            timestamper,
            structlog.processors.StackInfoRenderer(),
            # structlog.processors.format_exc_info,  # structlog.dev.ConsoleRenderer now formats exceptions itself
            structlog.stdlib.ProcessorFormatter.wrap_for_formatter,
        ],
        logger_factory=structlog.stdlib.LoggerFactory(),
        wrapper_class=structlog.stdlib.BoundLogger,
        cache_logger_on_first_use=True,
    )

    # root_logger = logging.getLogger("")
    # root_logger.addHandler(DatabaseLogHandler())
    # logging.root.addHandler(DatabaseLogHandler())
    # logging.root.setLevel(logging.INFO)
