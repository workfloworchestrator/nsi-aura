# Copyright 2024-2025 SURF.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from logging import Handler, LogRecord, config
from datetime import datetime
from uuid import UUID

import structlog

from aura.db import Session
from aura.model import Log, Reservation
from aura.settings import settings


class DatabaseLogHandler(Handler):
    def emit(self, record: LogRecord):
        """Filter structlog generated messages and store reservation related ones in the database."""
        with Session.begin() as session:
            # when msg attribute exists and is a dict, then the message is generated by structlog
            if hasattr(record, "msg") and isinstance(record.msg, dict):
                # check for anything that can map this message to a know reservation
                if "reservationId" in record.msg:
                    reservationId = record.msg["reservationId"]
                elif "connectionId" in record.msg and record.msg["connectionId"] != "None":
                    reservationId = (
                        session.query(Reservation.id)
                        .filter(Reservation.connectionId == UUID(record.msg["connectionId"]))
                        .scalar()
                    )
                elif "globalReservationId" in record.msg:
                    reservationId = (
                        session.query(Reservation.id)
                        .filter(Reservation.globalReservationId == UUID(record.msg["globalReservationId"]))
                        .scalar()
                    )
                elif "correlationId" in record.msg:
                    reservationId = (
                        session.query(Reservation.id)
                        .filter(Reservation.correlationId == UUID(record.msg["correlationId"]))
                        .scalar()
                    )
                else:
                    reservationId = -1
                # store the reservation related message in the database
                if reservationId >= 0:
                    session.add(
                        Log(
                            reservation_id=reservationId,
                            name=record.name,
                            module=record.module,
                            line=record.lineno,
                            function=record.funcName,
                            filename=record.filename,
                            timestamp=datetime.fromtimestamp(record.created),
                            message=record.msg["event"],
                        )
                    )


def init() -> None:
    timestamper = structlog.processors.TimeStamper(fmt="iso")
    pre_chain = [
        # Add the log level and a timestamp to the event_dict if the log entry
        # is not from structlog.
        structlog.stdlib.add_log_level,
        # Add extra attributes of LogRecord objects to the event dictionary
        # so that values passed in the extra parameter of log methods pass
        # through to log output.
        structlog.stdlib.ExtraAdder(),
        timestamper,
    ]

    # def extract_from_record(_, __, event_dict):
    #     """Extract thread and process names and add them to the event dict."""
    #     record = event_dict["_record"]
    #     event_dict["thread_name"] = record.threadName
    #     event_dict["process_name"] = record.processName
    #     return event_dict

    config.dictConfig(
        {
            "version": 1,
            "disable_existing_loggers": True,
            "formatters": {
                "plain": {
                    "()": structlog.stdlib.ProcessorFormatter,
                    "processors": [
                        structlog.stdlib.ProcessorFormatter.remove_processors_meta,
                        structlog.dev.ConsoleRenderer(colors=False),
                    ],
                    "foreign_pre_chain": pre_chain,
                },
                "colored": {
                    "()": structlog.stdlib.ProcessorFormatter,
                    "processors": [
                        # extract_from_record,
                        structlog.stdlib.ProcessorFormatter.remove_processors_meta,
                        structlog.dev.ConsoleRenderer(colors=True),
                    ],
                    "foreign_pre_chain": pre_chain,
                },
            },
            "handlers": {
                "default": {
                    "level": "DEBUG",
                    "class": "logging.StreamHandler",
                    "formatter": "colored",
                },
                "file": {
                    "level": "DEBUG",
                    "class": "logging.handlers.WatchedFileHandler",
                    "filename": "aura.log",
                    "formatter": "plain",
                },
                "database": {
                    "level": "DEBUG",
                    "class": "aura.log.DatabaseLogHandler",
                    "formatter": "plain",
                },
            },
            "loggers": {
                "": {
                    "handlers": ["default", "file", "database"],
                    "level": settings.LOG_LEVEL,
                    "propagate": True,
                },
                # Set `level` to `INFO` or `DEBUG` here for detailed SQLAlchemy logging.
                "sqlalchemy.engine": {"handlers": ["default"], "level": "WARNING", "propagate": False},
                # "uvicorn.error": {
                #     "propagate": False
                # }
                "uvicorn.access": {
                    "handlers": ["default", "file", "database"],
                    "level": settings.LOG_LEVEL,
                    "propagate": True,
                },
                "uvicorn.error": {
                    "handlers": ["default", "file", "database"],
                    "level": settings.LOG_LEVEL,
                    "propagate": True,
                },
            },
        }
    )

    # logging.getLogger("uvicorn.error").disabled = True
    # logging.getLogger("uvicorn.access").disabled = True

    structlog.configure(
        processors=[
            structlog.stdlib.add_log_level,
            structlog.stdlib.PositionalArgumentsFormatter(),
            timestamper,
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.stdlib.ProcessorFormatter.wrap_for_formatter,
        ],
        logger_factory=structlog.stdlib.LoggerFactory(),
        wrapper_class=structlog.stdlib.BoundLogger,
        cache_logger_on_first_use=True,
    )

    # root_logger = logging.getLogger("")
    # root_logger.addHandler(DatabaseLogHandler())
    # logging.root.addHandler(DatabaseLogHandler())
    # logging.root.setLevel(logging.INFO)
